# Проект Алгоритмы и структура данных

Проект содержит в себе 4 модуля:

- GeneratePresetImpl (отвечает за генерацию пресета армии противника)
- SimulateBattleImpl (отвечает за осуществление симуляции боя)
- SuitableForAttackUnitsFinderImpl (отвечает за создание перечня подходящих для атаки юнитов)
- UnitTargetPathFinderImpl (отвечает за поиск наикратчайшего пути между атакующим и атакуемым юнитом)

### Требования
- Java 21
- Gradle
### Сборка
```sh
gradle jar
```
### Запуск
Сформированный Jar-файл из папки build/libs/*.jar переименовываем в obf.jar и сохраняем в папку jars с игрой.

(уже готовый файл лежит в корне проекта)

## Сложность алгоритмов

### I. Генерация армии противника (метод generate) O(nlogn)
#### 1. Алгоритмический подход
   Выбран жадный алгоритм с предварительной сортировкой. Подход состоит из:

- Сортировки юнитов по эффективности (отношение урона к стоимости, затем здоровья к стоимости)

- Последовательного заполнения армии, начиная с самых эффективных юнитов

- Использования заранее подготовленных и перемешанных координат для случайного размещения

- Ограничения количества юнитов каждого типа (MAX_UNITS_PER_TYPE)

##### 2. Обоснование алгоритмической сложности

   Пусть:
- n — количество типов юнитов в unitList

- m — среднее количество юнитов каждого типа, которые можно купить

- P — общее количество позиций в армии (ARMY_WIDTH × ARMY_HEIGHT = 63)

#### Пошаговый анализ сложности:

- Сортировка юнитов: O(n log n)

- Генерация координат: O(P) где P = 63

- Перемешивание координат: O(P) (внутри Collections.shuffle())

- Основной цикл по юнитам:

    Внешний цикл: O(n) итераций

    Внутренний цикл: O(min(MAX_UNITS_PER_TYPE, remainingPoints/unit.getCost()))

    В худшем случае общее количество размещаемых юнитов ограничено P (63 позиции)

Итоговая сложность: O(n log n + P), где P = 63 — константа.

#### 3. Достигнута ли сложность O(n×m)?
   Да, достигнута, и даже лучше.
   Фактически алгоритм имеет сложность O(n log n + U), где:

   n — количество типов юнитов

   U — общее количество размещенных юнитов (не более 63)

Поскольку U ≤ P = 63 (константа), а m в контексте задачи — это среднее количество юнитов каждого типа, то:

В худшем случае U = n × m (если размещаем все возможные юниты)

Но на практике U ≤ 63, что ограничивает сложность до O(n log n + 63) = O(n log n)

Вывод: Алгоритм эффективнее, чем O(n×m), так как количество юнитов ограничено размером армии (63), а не количеством доступных юнитов каждого типа.

### II. Симуляция боя (метод simulate) O(n^2logn)
#### 1. Алгоритмический подход
   Выбран покомандный поочередный подход с сортировкой по приоритету атаки.
   
Основные особенности:

- В начале каждого раунда собираются живые юниты с обеих сторон

- Все живые юниты объединяются в общий список и сортируются по убыванию базовой атаки

- Юниты атакуют в порядке убывания силы атаки (самые сильные первыми)

- Используется список killedThisRound для отслеживания юнитов, убитых в текущем раунде

- Бой продолжается до тех пор, пока в одной из армий не останется живых юнитов

#### 2. Обоснование алгоритмической сложности
   Пусть:

- n₁ — количество юнитов в армии игрока

- n₂ — количество юнитов в армии компьютера

- n = n₁ + n₂ — общее количество юнитов

- k — количество раундов боя (в худшем случае)

#### Анализ сложности одного раунда:

- Сбор живых юнитов: O(n₁) + O(n₂) = O(n)

- Проверка окончания боя: O(1)

- Объединение списков: O(n)

- Сортировка всех живых юнитов: O(a log a), где a — количество живых юнитов в раунде (a ≤ n)

- Цикл атаки по отсортированным юнитам: O(a) итераций

- Внутри цикла: поиск цели attack() + логгирование O(1) + выполнение атаки O(1)

#### Сложность одного раунда: O(n + a log a), где a ≤ n

#### Общая сложность для k раундов: O(k × (n + a log a))

В худшем случае, когда юниты убивают по одному за раунд:

- k = n (количество раундов равно общему количеству юнитов)

- В каждом раунде a ≈ n (почти все юниты живы)

- Общая сложность: O(n × (n + n log n)) = O(n² + n² log n) = O(n² log n)

#### 3. Достигнута ли сложность O(n² log n)?
   Да, достигнута, и в худшем случае именно такая сложность.

Обоснование:

- В худшем случае (когда юниты слабые и убивают максимум по одному противнику за раунд) будет n раундов

- В каждом раунде сортировка n живых юнитов: O(n log n)

- Остальные операции в раунде: O(n)

- Итого: n × (n + n log n) = O(n² log n)

#### Критические факторы:

- Сортировка в каждом раунде — O(n log n)

- Количество раундов линейно зависит от n в худшем случае

- Умножение дает O(n × n log n) = O(n² log n)

Примечание: На практике сложность может быть меньше, так как:

- Количество живых юнитов a уменьшается с каждым раундом

- Сильные юниты могут убивать несколько противников за раунд

- Но верхняя оценка сложности действительно O(n² log n)

### III. Отбор целей для атаки (метод getSuitableUnits) O(n)
#### 1. Алгоритмический подход
   Выбран прямой линейный проход с использованием HashSet для проверки занятости. 
   
Алгоритм:

- Для каждого ряда (List<Unit> row) создается множество занятых Y-координат

- Затем для каждого юнита в ряду проверяется, свободна ли соседняя клетка (слева или справа в зависимости от isLeftArmyTarget)

- Если соседняя клетка свободна, юнит добавляется в результат

#### 2. Обоснование алгоритмической сложности
   Пусть:

- r — количество рядов (размер unitsByRow)

- cᵢ — количество юнитов в i-м ряду

- n = Σcᵢ — общее количество юнитов

#### Пошаговый анализ:

1. Внешний цикл по рядам: O(r) итераций

2. Для каждого ряда:

- Создание HashSet и добавление всех Y-координат: O(cᵢ)

- Второй проход по юнитам ряда: O(cᵢ)

- Проверка в HashSet: O(1) в среднем случае

3. Итог: для каждого ряда выполняется 2 × O(cᵢ) операций

#### Общая сложность: O(Σ2cᵢ) = O(2n) = O(n)

#### 3. Достигнута ли сложность O(n)?
   Да, достигнута.

Алгоритм имеет строго линейную сложность O(n) относительно общего количества юнитов:

- Каждый юнит обрабатывается дважды: один раз для добавления в HashSet и один раз для проверки соседней клетки

- Операции с HashSet выполняются за O(1) в среднем случае

- Константный множитель 2 не влияет на асимптотическую сложность

#### Важные замечания:

- Алгоритм оптимален по времени — нельзя сделать лучше, чем O(n), так как нужно проверить каждый юнит

### IV. Поиск кратчайшего пути (метод getTargetPath) A-Star O(WH*logWH)
#### 1. Алгоритмический подход
   Выбран алгоритм поиска пути A (A-star)* с эвристикой Манхэттенского расстояния. 
   
Ключевые особенности реализации:

- Используется приоритетная очередь (открытый список) с сортировкой по значению f = g + h

- Учитывается 8 направлений движения (включая диагонали)

- Разные стоимости перемещения: 10 для ортогональных направлений, 14 для диагональных

- Для ускорения проверок используются хэш-таблицы (HashMap) для хранения gScore, fScore и cameFrom

#### 2. Обоснование алгоритмической сложности
   Пусть:

- W = 27 (ширина поля)

- H = 21 (высота поля)

- N = W × H = 567 (максимальное количество узлов)

- E = 8 × N (максимальное количество рёбер, т.к. 8 направлений)

#### Анализ сложности A*:

1. Инициализация: O(N) для создания obstacles матрицы

2. Основной цикл A*:

- В худшем случае посещает все N узлов

- Для каждого узла проверяет до 8 соседей

- Операции с PriorityQueue (добавление/удаление): O(log M), где M — размер очереди (≤ N)

- Операции с HashMap: O(1) в среднем случае

#### Теоретическая сложность A*:

- В наихудшем случае: O(N × log N) = O(WH × log WH)

- В лучшем случае (прямая линия без препятствий): O(d), где d — длина пути

#### Конкретно для данной реализации:

- Максимально N = 567 узлов

- Сложность: O(567 × log 567) ≈ O(567 × 9.1) ≈ O(5160) операций

#### 3. Достигнута ли сложность O(WH × log WH)?
   Да, достигнута.

Алгоритм A* в худшем случае имеет сложность O(bᵈ), где b — коэффициент ветвления (8), d — глубина решения.
Но при использовании оптимальной эвристики и с учетом ограниченного размера поля (27×21), верхняя оценка действительно O(WH × log WH).

#### Обоснование:

1. Каждый узел обрабатывается максимум один раз

2. Операции с приоритетной очередью: O(log M) ≤ O(log(WH))

3. Количество узлов ≤ WH

4. Итог: O(WH × log WH)

#### 4. Использован ли эффективный алгоритм поиска пути (A* или аналогичный)?
   Да, использован алгоритм A*, который является эффективным и оптимальным (при соблюдении условий):

1. Эвристика допустима: Манхэттенское расстояние ≤ реального (с учётом диагоналей)

2. Эвристика монотонна: выполняется неравенство треугольника

3. Алгоритм находит кратчайший путь при данных условиях

Вывод: Алгоритм корректный и эффективный для поля размером 27×21, сложность соответствует O(WH × log WH).
